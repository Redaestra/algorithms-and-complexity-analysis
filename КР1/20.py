"""
Возьмём первую колонку. В исходной матрице элементы этой колонки — это 1, M+1, 2M+1, ....
Если найти, в каком порядке сейчас идут эти значения, можно восстановить перестановку строк.

Как определить перестановку колонок?
Аналогично, берём первую строку. В исходной матрице элементы первой строки — это 1, 2, 3, ..., M.
По текущему порядку этих чисел можно узнать, как перемешались колонки.

План действий:

Вычисляем, в каком порядке сейчас стоят строки (по первой колонке).

Вычисляем, в каком порядке стоят колонки (по первой строке).

Вычисляем обратные перестановки (чтобы вернуть в исходное положение).

Применяем операции R X Y и C X Y, чтобы вернуть матрицу в исходное состояние.
"""
def solve():
    # === Чтение входных данных ===
    n_m = input().split()
    n = int(n_m[0])
    m = int(n_m[1])
    
    # Чтение матрицы (n строк по m чисел)
    a = []
    i = 0
    while i < n:
        row_str = input().split()
        row = []
        j = 0
        while j < m:
            row.append(int(row_str[j]))
            j += 1
        a.append(row)
        i += 1

    # === Определение перестановки строк ===
    # В исходной матрице первый столбец = [1, M+1, 2M+1, ...]
    # Сейчас по нему можно понять, где какая строка
    row_order = [0] * n  # row_order[i] = какой номер исходной строки стоит сейчас на месте i
    i = 0
    while i < n:
        # текущий элемент в первом столбце
        val = a[i][0]
        # вычисляем, какой строке он принадлежал изначально:
        # (i-1)*M + 1 <= val <= i*M
        original_row = (val - 1) // m  # 0-based
        row_order[i] = original_row
        i += 1

    # === Определение перестановки колонок ===
    col_order = [0] * m
    j = 0
    while j < m:
        val = a[0][j]
        # определяем исходную колонку:
        # val = (0)*M + col_index => col_index = val - 1
        original_col = (val - 1) % m  # 0-based
        col_order[j] = original_col
        j += 1

    # === Генерация операций для восстановления ===
    # Мы должны привести row_order и col_order к [0,1,2,...]
    # Будем переставлять их, фиксируя один элемент за другим

    operations = []

    # --- Исправляем строки ---
    i = 0
    while i < n:
        # Пока на месте i не стоит строка i, ищем где она и меняем
        if row_order[i] != i:
            target = row_order[i]
            # ищем, где находится строка, которая должна стоять здесь
            j = i
            while j < n and row_order[j] != i:
                j += 1
            # теперь j — индекс строки, которую нужно обменять с i
            # выполняем обмен
            tmp = row_order[i]
            row_order[i] = row_order[j]
            row_order[j] = tmp
            # фиксируем операцию
            operations.append(("R", i + 1, j + 1))
        i += 1

    # --- Исправляем колонки ---
    i = 0
    while i < m:
        if col_order[i] != i:
            target = col_order[i]
            j = i
            while j < m and col_order[j] != i:
                j += 1
            tmp = col_order[i]
            col_order[i] = col_order[j]
            col_order[j] = tmp
            operations.append(("C", i + 1, j + 1))
        i += 1

    # === Вывод результата ===
    print(len(operations))
    i = 0
    while i < len(operations):
        op = operations[i]
        print(op[0], op[1], op[2])
        i += 1


# Запуск решения
solve()
