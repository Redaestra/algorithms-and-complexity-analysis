"""
Ключевая идея этой задачи - поддерживать стек активных отрезков, которые ещё могут включать новые вершины.
Верхушка стека — минимальный по длине отрезок, который ещё может включать будущие точки.

Когда добавляется новый отрезок (a, b):

Если верхушка стека полностью включает новый отрезок → она длиннее, и её можно убрать.

Новый отрезок добавляется на вершину.

Для каждой точки c_j:

Проверяем верхушку стека:

Если точка лежит внутри верхушки → это минимальный вложенный отрезок.

Если нет → снимаем верхушки, пока стек пуст или пока верхушка подходит.
"""


# Чтение входных данных
n = int(input())
segments = []
i = 0
while i < n:
    line = input().split()
    a = int(line[0])
    b = int(line[1])
    segments.append((a, b, i + 1))  # индекс 1-based
    i += 1

m = int(input())
queries = []
i = 0
while i < m:
    c = int(input())
    queries.append((c, i))  # сохраняем исходный индекс
    i += 1

# Ответы для каждой точки
answers = [-1] * m

# Стек активных отрезков: верхушка — минимальный вложенный
stack = []
seg_idx = 0

for point, q_idx in queries:
    # добавляем все новые отрезки, которые начинаются до точки
    while seg_idx < n and segments[seg_idx][0] <= point:
        a, b, idx = segments[seg_idx]
        # удаляем из стека отрезки, которые полностью включают текущий (больше длиной)
        while stack and stack[-1][1] >= b:
            stack.pop()
        stack.append((a, b, idx))
        seg_idx += 1

    # ищем минимальный отрезок, который включает точку
    while stack and not (stack[-1][0] <= point <= stack[-1][1]):
        stack.pop()

    if stack:
        answers[q_idx] = stack[-1][2]
    else:
        answers[q_idx] = -1

# Выводим ответы в порядке входных запросов
i = 0
while i < m:
    print(answers[i])
    i += 1
